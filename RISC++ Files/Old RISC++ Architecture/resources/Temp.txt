##	RISC++ FEATURE SUMMARY

RISC++ builds on the author’s research of a variety of online and print sources to provide a unique solution to the problem of the fast execution of a serial instruction stream. The following features of RISC++ facilitate high ILP with a simplified hardware design. These will be explained in more depth later in the document.

1. The Scalar Processing Unit supports high ILP with scalar data randomly scattered in memory.
2. The Vector Processing Unit supports high data parallelism with up to 512 bits of results per cycle.
3. Out of Order Execution improves ILP by eliminating pipeline stalls as instructions wait for data.
4. The Instruction Cache manages streams of fixed length instructions.
5. The Scalar Data Cache manages random data with a variable length from 8 to 64 bits.
6. The Vector Data Cache manages streams of parallel data which are 128, 256 or 512 bits wide.
7. Virtual Registers facilitate the elimination of data dependencies to support high ILP.
8. Each Virtual Register is mapped to a specific memory location in the Register Save Area (RSA). 
9. The Register Save Engine (RSE) continually saves modified registers to speed up thread switching.
10. RISC++ uses Typed Registers to specify data types such as Integer and Floating point.
11. The Data Types, for each typed register, are specified in 8-bit Type/Status Registers (TSRs).
12. The numbers and sizes of the Virtual Registers are:
	a.	16 x 64-bit Control Registers, control the operation of a single thread.
	b.	64 x 64-bit Fast Integer Registers, operate in a single instruction cycle.
	c.	64 x 64-bit Random Access Typed Scalar Registers.
	d.	64 x 64-bit Queued Access Typed Scalar Registers.
	e.	128 x 64-bit Stacked Access Typed Scalar Registers.
	f.	64 x 128-bit Queued Access Typed Vector Registers.
13.	Virtual Registers are renamed to Physical Registers during instruction execution.
14.	Multiple parallel Execution Units (EUs) facilitate high Instruction Level Processing (ILP).
15.	The types of Execution units are:
	a.	Instruction Control Unit: Fetches, Decodes and Dispatches instructions.
	b.	Load/Store Unit: Moves data between memory and various register banks.
	c.	Fast Integer Unit: Single cycle Integer instructions.
	d.	Scalar Multiply/Add Unit: Multiply, Add/Subtract and Logical. Typed Scalar data.
	e.	Scalar Special Operations Unit: Divide, Square Root and trigonometric. Typed Scalar Data.
	f.	Vector Multiply/Add Unit: Multiply, Add/Subtract, Logical. Typed Vector data. 
	g.	Vector Special Operations Unit: Divide, Square Root and trigonometric. Typed Scalar Data.
16.	Multiport Register Banks allow parallel reading and writing of registers by parallel EUs.
17.	Hardware designers can optimize:
	a.	The number of physical Fast Integer, Typed Scalar and Typed Vector Registers.
	b.	The number of read and write ports for various physical register banks.
	c.	The number of various kinds of Execution Units.
18.	Conditional Instructions streamline control logic and reduce the number of branches.
19.	Queued Operand Instructions also reduce data dependencies and reduce binary code size.
20.	Simultaneous Multithreading uses EUs more efficiently. Also, read this PDF. 