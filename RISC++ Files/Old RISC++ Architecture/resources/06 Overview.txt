# Overview of the RISC++ Hardware


## Instruction Control Unit (ICU)

The ICU Fetches, Decodes, and Dispatches instructions to the various Execution Units (EUs). It also handles Branches, Interrupts,  and Conditional Instructions. It has a simple and fast design. It dispatches instructions in the order that they are received from the Instruction Cache, as defined by the Instruction Pointer. RISC++ has no hardware branch prediction but depends on software to schedule compare instructions which set condition bits and the instructions that access those bits. However software algorithms for branch prediction may be utilized. The use of conditional instructions reduces the number of branches and mitigates the need for hardware branch prediction.

Conditional Instructions and Branches use an array of 32 Condition Bits (CBs) which are set by Compare, Test or Bitwise Logical instructions in the various EUs. The CBs can be set simultaneously by different instructions running in parallel. The ICU is responsible for synchronizing the setting and testing of CBs so that no bit is tested before it is set. Conditional Instructions are dispatched if a tested CB is true and skipped if the CB is false. If the bit is in the process of being updated, the instruction is placed in a wait queue and will be dispatched when the CB is set and tested as true. Branches test for a CB to be true or false, or for the value of a 16 bit Integer Register to be zero or not zero. Compares by the Fast Integer Unit will produce the results in a single cycle. Compares by the Typed Scalar Unit may take many cycles to produce the resulting condition bit.

Once an instruction is dispatched, the Fast Integer Unit and the Load/Store Unit will wait until the source operands are available and then execute the instructions in the order they are dispatched from the ICU. The Typed Scalar Unit will wait until the source operands are available then execute the instructions immediately using [Out of Order Execution (OoOE)](https://en.wikipedia.org/wiki/Out-of-order_execution). The status field in the Type/Status Register (TSR) determines whether a source operand is available and whether or not an interrupt should be generated. 

The Vector Unit waits until the source operands are available and then executes them in the order that the instruction is dispatched. Vector instructions may take many cycles to complete and the result of the entire operation is indicated in the status field of the 16 bit Type/Status/Length register (TSLR) of the target vector. The Vector Unit does not produce interrupts but accumulates the status of all the elements of several vectors in a 16 bit register which can be examined at key points in the program.


## Load-Store Unit (LSU)

### Internal Registers

The internal registers include: Control Registers (CR), Integer Registers (IR), Scalar Registers (SR), Type-Status Registers (TSR), and Vector Registers (VR). Scalar registers can contain integer or floating-point data. Load instructions transfer data from memory to the various registers. Store instructions transfer data from the registers to memory. Load instructions convert data from the format in memory into the format that the internal registers require. Store instructions convert data from the format in the register to that in memory. This will be explained further when we examine the various processing units in more detail.

### Scalar and Vector Caches

The LSU moves data between main memory and the internal registers. The most recently used data is held in one of two high speed data caches. The Scalar Data Cache holds variable length data items which are from 8 to 128 bits in length, and which are accessed randomly. The Vector Data Cache holds variable length data items which are 1 to 256 bytes long, and which are  accessed sequentially. Most of the time the vector cache accesses a full 256 bytes of data. The Vector Load and Store instructions can be used to save or retore the entire set of registers in the various EUs when task switching. Most often the instructions can are used to move data to or from a 256 byte long Vector Register. When The length the Vector is defined in the TSLR. If a Load Vector instruction has a length of less than 256, the remaining bytes will be set to zero.

The caches are usually manged automatically by the hardware, but software can also prefetch and flush the caches. The Wikipedia article [CPU Cache](https://en.wikipedia.org/wiki/CPU_cache) gives a good description of how various caches work. Because of the randomness of the Scalar Cache, it would be best to design it as “set associative”. The Vector Cache, on the other hand, would be a good candidate for a “direct mapped” cache, because the data addresses are predictable and rarely conflict. The vector cache can also be called a "streaming cache."

### Internal Registers

The internal registers include: Control Registers (CR), Integer Registers (IR), Scalar Registers (SR), Type-Status Registers (TSR), and Vector Registers (VR). Scalar registers can contain integer or floating-point data. Load instructions transfer data from memory to the various registers. Store instructions transfer data from the registers to memory. Load instructions convert data from the format in memory into the format that the internal registers require. Store instructions convert data from the format in the register to that in memory. This will be explained further when we examine the various processing units in more detail.

### Typed Pointers

There are two different kinds of Load and Store instructions. In the first kind the data address, and the data type are specified by fields in the instruction. In the second kind, the address and data type are specified by fields in Typed Pointers.  A typed pointer contains the data type and other control information in the upper 16 bits, and the data address in the lower 48 bits, of a 64-bit pointer register. The data address is calculated by adding the address in a typed pointer register to that of an index register. The data type specified by the type field in the pointer register also provides information on the length of the data and how the data is to be converted as it is moved between memory and the registers. Typed pointers are very flexible and powerful especially when used with vector data. They closely match the concept of reference variables in C++.

### Saving Registers for Context Switching

RISC++ defines many internal registers which are needed to ensure high speed execution of individual threads. This means that many registers need to be saved and restored when the processor switches threads (context switching). In earlier versions of RISC++ this problem was addressed by defining a Register Save Engine (RSE). The RSE would continually scan the various register banks and save modified registers into an area of the Scalar Data Cache specified by a Register Save Pointer (RSP). Now that I have settled on the 256 byte vector, and defined all the register banks to be 256 bytes, software can use the vector data cache for saving and restoring registers. This ensures that only those registers which are critical to operating thread are saved and restored.

Only local registers need to be saved because global registers are used by all threads. When registers are modified there is a bit set for each 128 bit group of registers. The software will issue an Store Modified Integer Registers (SMIR) at various checkpoints. This will store any of the 16 and 64 bit Fast Integer Registers that have been modified since the last store. The Load Modified Integer Registers (LMIR) instruction restores any stored registers after a task switch. Then the modified bits are all set to zero. Similarly the Store Modified Scalar Registers (SMSR) stores the modified the 8 bit TSRs and 64 bit data registers. The Load Modified Scalar Registers (LMSR) restores them.

### Software Isolated Processes and Virtual Memory

When parallel processing systems share memory, it creates problems with both performance and security. One way to combat these problems is to use hardware features to facilitate Process Isolation. When processes, (or threads as defined by RISC++), are isolated from one another, they are not able to share memory. All  Inter-process Communication is performed through software interrupts and implemented in the Operating System. Process Isolation also makes cache management hardware faster and less complex because it does not need to support inefficient schemes of maintaining Cache Coherence.
 
The X86 has evolved from a time CPUs when memory was smaller and more expensive than it is today. As a result, the way the architecture implements Virtual Memory is complex and cumbersome. Now that real memory is larger and cheaper, and as security has become a more complex problem, a new Virtual Memory system needs to be defined. RISC++ has left Virtual Memory undefined for now. I tend to think it needs to be simple and flexible and different for different Operating Systems.  Perhaps some collaborative thinking could produce a new definition based on large amounts of real memory and modern security issues.

## Integer Processing Unit (IPU)

The IPU is used primarily for simple arithmetic and logical instructions such as Add, Subtract, AND, OR, XOR, Shift Left/Right, etc. The IPU does not support multi-cycle instructions like Multiply and Divide. If the program needs to perform Multiply and Divide on integer data, it needs to use the Scalar Processing Unit (SPU). The IPU interfaces with all the other Execution Units The IPU defines the following registers:

1. (16 x 1-bit) Condition Bits. (CB)

* Used by the Instruction control unit for conditional instructions.
* Set by Compare, test and bit logical instructions in various EUs
* Each bit is set in parallel, somtimes taking many cycles to set.
* Conditional Instructions are dispatched if bit is true, skipped otherwise.

2. (16 x 16-bit) Integer Short Registers. (ISR)

* ISR0 reads x0000, Writes are ignored.
* ISR1 reads xFFFF, Writes are ignored.
* Used by ICU to control interrupts and other functions.
* Used by LSU to for vector indexing, vector length and other functions.
* Used for loop counting and other times short integers are needed.
* Used to read/write Type/Status Registers in Scalar Unit.
* Used to read/write Type/Status/Length Registers in Vector Unit.

3. 28 x 64 bit Integer Long Registers (ILR)

* IRL0 to IRL0 are system pointers. Can only by updated in Priviledged Mode.
* ILR0 Base pointer for all memory accessed by thread.
* ILR1 Active Instruction Pointer.
* ILR2 New Instruction Pointer for Hardware Interupts
* ILR3 New Instruction Pointer for Software Interupts
* ILR4 Interrupt Stack Pointer. Saves and restores IP and 64 bit registers.

IPU Add and Subtract instructions assume 16-bit signed or 64-bit signed data. The data types in memory can be 8, 16, 32, or 64-bit integer; signed and unsigned. Data is converted between memory and register format during Loads and Stores. The IPU is used for loop counters, address arithmetic, logical operations, bit manipulation, and so forth.
The IPU exchanges data between the Integer Registers and registers in all the other EUs. 

This may cause stalls especially when the IPU is waiting for a register from the SPU. These stalls are considered acceptable for overall system performance. However, to avoid stalls in the IPU, the compiler should separate the tasks performed by the IPU and SPU. There is a trade-off between the goal of having a fast instruction cycle for serial instructions, and the goal of producing high Instruction Level Processing using Out of Order Execution. However, if the IPU is used for things like loop control and pointer manipulation, and the SPU is used for other calculations, then the parallelism between and within the two EUs can be optimized. 

## Typed Scalar Processing Unit

## Typed Vector Processing Unit

